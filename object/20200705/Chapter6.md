# 6장 메시지와 인터페이스

## Intro

- 객체지향 프로그래밍에 대한 흔한 오해 : 애플리케이션은 클래스의 집합
    - 클래스는 구현도구에 불과. 집착하면 경직되고 유연하지 못한 설계가 될 수 있음
- 객체지향 애플리케이션의 가장 중요한 재료는 말 그대로 객체 (클래스가 아니다!)

---

세훈 : entity → controller로 설계하는 방법과 controller → entity 설계하는 방법 두 가지가 있을 수 있는데, entity 부터 바라보면 데이터 중심의 설계가 되고, controller 부터 설계하면 책임 중심의 설계가 되는 것 같다.

도한 : layered architecture가 결국은 책임 주도 설계의 결과 아닌가?

학현 : 특정 역할을 수행하는 클래스가 하나만 존재한다면, 그것은 클래스 중심의 설계로 볼 수 있는 것은 아닌가?

## 1. 협력과 메시지

### 클라이언트 서버-모델

- 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포
- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적
- 대부분의 사람들은 객체가 수신하는 메시지의 집합에만 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하자

---

도한 : 인터페이스부터 짜다보니 수신자 입장에서만 생각하게 된다.

세훈 : 개발을 하다보면 계속해서 overloading을 하게 된다. 수신자의 입장에서 메시지가 이렇게 올거야 생각하고 개발을 했는데, 계속해서 추가되는 느낌이었다.

### 메시지와 메시지 전송

- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통
    - 메시지 : 오퍼레이션명 + 인자
    - 메시지 전송 : 메시지 + 메시지 수신자

### 메시지와 메서드

- 메서드 : 메시지를 수신했을 때 실제로 실행되는 함수
- 전통적 방식의 개발은 코드의 의미가 컴파일 시점과 실행 시점에 동일하지만, 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결하므로 컴파일 시점과 실행 시점의 의미가 달라질 수 있음
- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 함

---

도한 : 컴파일 시점과 런타임 시점의 코드 의미가 다른 것이 디버깅할 때 너무 어려운것 같다.

### 퍼블릭 인터페이스와 오퍼레이션

- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라함
- 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라 부름
    - 오퍼레이션 : 수행 가능한 어떤 행동에 대한 추상화
- 퍼블릭 인터페이스의 관점에서 메서드 호출보다는 오퍼레이션 호출이라는 용어가 더 적합함

---

도한 : 오퍼레이션이라는 말은 잘 못들은 것 같다.

세훈 : 메시지란 말도 잘 안쓴다. 

관수 : 개념을 분리해서 설명해주는 것만으로도 의미가 있는 것 같다.

### 시그니처

- 시그니처 : 오퍼레이션의 이름 + 파라미터 목록
- 메서드 : 시그니처 + 구현
- 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것

---

학현 : 패키지가 다른데 인터페이스가 같은 경우가 많다.

세훈 : 처음 팀에 involving되기 때문에 중복 코드를 만드는 사례가 많아지는 것 같다.

## 2. 인터페이스와 설계 품질

- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야
- 최소주의를 따르면서 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법

### 디미터 법칙

- 예졔 : 하나의 객체가 다른 객체들과 강하게 결합되어 있음
- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙
    - 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라
    - 객체의 협력 경로를 제한하면 결합도를 효과적으로 나눌 수 있음
- 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 하라
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체

---

학현 : 디미터 법칙을 위해서 체이닝된 합성 객체를 리턴하는 상황에서 메서드들이 너무 많이 늘어나는 것 같다.

### 묻지 말고 시켜라

- 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조함
    - 상태를 묻는 오퍼레이션보다는 행동을 요청하는 오퍼레이션으로 대체하라
- 묻지말고 시켜라 법칙에 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있음
    - 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법이 없는지 고민하라.
    - 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하면 객체가 책임져야 하는 어떤 행동이 외부로 누수된 것

### 의도를 드러내는 인터페이스

- 메서드의 이름은 어떻게가 아니라 무엇을 하는지를 드러내야 함
    - 의도를 드러내는 선택자 패턴 : 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서 객체가 협력 안에서 수행해야 하는 책임에 관해 고민 해야함
- 객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 함
    - 이해하기 쉽고 유연한 동시에 협력적인 객체를 만드는 가장 기본적인 요구사항

---

학현 : JPA 메서드들은 어떻게를 의미하는 것 같다. 

세훈 : isSatisfiedBy에서 By를 빼야하는것 아닌가??

### 함께 모으기

- 디미터 법칙, 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스를 이해할 수 있는 가장 좋은 방법 중 하나는 이런 원칙을 위반하는 코드의 모습을 살펴보는 것
- 디미터 법칙, 묻지 말고 시켜라 원칙에 따라 코드를 리팩터링한 후에 Audience 스스로 자신의 상태를 제어하게 됐다는 점에 주목
    - 구현이 객체 사이에 드러나지 않기 때문에 결합도는 낮아짐
    - 책임이 잘못된 곳에 할당될 가능성이 낮기 때문에 객체의 응집도 역시 높아짐
- 인터페이스에 의도를 드러내자
    - 오퍼레이션의 이름은 협력이라는 문맥을 반영해야 함
    - 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야 함
        - 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 함

## 3. 원칙의 함정

- 설계는 트레이드오프의 산물
- 원칙이 현재 상황에 부적합하다고 판단되면 과감하게 원칙을 무시하라
    - 원칙을 아는 것보다 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력

### 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다

- 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정

### 결합도와 응집도의 충돌

- 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다.
- 결과적으로 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.

## 4. 명령-쿼리 분리 원칙

- 가끔씩은 필요에 따라 물어야 한다는 사실을 납득했다면 명령-쿼리 분리 원칙이 도움이 됨
    - 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침 제공
- 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
    - 프로시저 : 부수효과를 발생 시킬 수 있지만 값을 반환하지 않음
    - 함수 : 값을 반환할 수 있지만 부수효과를 발생시킬 수 없음
- 명령과 쿼리는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름
    - 명령은 상태를 변경할 수 있지만 상태를 반환해서는 안됨
    - 쿼리는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안됨

### 반복 일정의 명령과 쿼리 분리하기

- 하나의 메서드 안에서 명령과 쿼리를 동시에 수행하고 있어 버그를 찾기 힘들었음
- 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있음

### 명령-쿼리 분리와 참조 투명성

- 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있게 된다. 참조 투명성이라는 특성을 잘 활용하면 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있음
- 컴퓨터의 세계와 수학의 세계를 나누는 가장 큰 특징은 부수효과
    - 부수 효과를 발생시키는 두 가지 대표적인 문법은 대입문과 함수
- 참조투명성 : 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성
    - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있으므로 식을 쉽게 계산할 수 있음
    - 모든 곳에서 함수의 결괏값이 동일하므로 식의 순서를 변경하더라도 각 식의 결과를 달라지지 않음
- 객체지향 패러다임은 객체의 상태 변경이라는 부수효과가 만연한 곳인데, 명령-쿼리 분리 원칙으로 이러한 부수효과를 제한적으로 줄여 참조 투명성의 혜택을 누릴 수 있음
- 명령형 프로그래밍 : 부수효과를 기반으로하는 프로그래밍
- 함수형 프로그래밍 : 부수효과가 존재하지 않는 수학적인 함수에 기반하는 프로그래밍

### 책임에 초점을 맞춰라

- 디미터 법칙 / 묻지 말고 시켜라 / 의도를 드러내는 인터페이스 설계
    - 쉬운 방법은 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것
    - 즉 책임 주도 설계를 하라