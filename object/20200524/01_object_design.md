# 서문 

- 도한 : 아무리 시간이 흘러도 이론이 실무가 넘을 수 없을 것 같다.
- 승욱 : 그래서 이 책이 코드 위주로 설명하려고 각을 잡는 것 같다. 
- 관수 : 이론은 틀이라고 생각할 수 있고, 프레임워크들도 이론을 토대로 만들어진
것이고, 큰 틀이기 때문에 이론을 폄훼할 필요는 없다. 
- 학현 : 이론을 적용하기 위해서는 멤버들이 모두 이론에 대한 인지를 동일하게
공감하고 있어야 가능하지 않을까

# 소프트웨어의 세 가지기능

- 제대로 동작
- 변경이 용이해야한다.
- 커뮤니케이션이 쉬어야한다. 

# 예제 코드의 문제점 

## 도한 

- 커뮤니케이션이 힘듦 
- 코딩을 하면서도 이해하기 힘듦

## 학현

- 스토리 텔링이 안된것 같다. 

## 승욱 

- 테스트 코드 짜기 힘들 것 같다. 
  - 로직이 분산되어있지 않아서, 테스트코드를 작성하기는 용이할듯 하지만,
  유지보수는 어려울 것 같다. 

## 세훈 

- Audience와 TicketOffice가 왜 있는지 존재의의 자체가 의문스럽다. 
  - 실질적으로 필요없는 class들이 정의되어있다. 

## 관수

- 절차지향에 대해서 잘 설명한 코드 같다. 

# 이해가능한 코드

- 동작이 예상범위 안에 있는 코드 

# 설계 개선하기 

- 너무 세세한 부분까지 알지못하도록 정보를 차단하자.
 - Encapsulation : 개념적이거나 물리적인 차원에서 객체 내부의 세부사항을 감추는것
   - 세훈 : Encapsulation이 와닿지 않는 것은, 그렇게 코딩을 많이 하지 아니여서가 아닐까?

## 절차지향 프로그래밍과 객체지향 프로그래밍 

- 절차지향 프로그래밍 : 프로세스와 데이터를 별도의 모듈에 배치 
- 객체지향 프로그래밍 : 프로세스와 데이터를 동일한 모듈에 배치 
 - 적절한 객체에 적절한 책임 (기능)을 분산시키는 것 
 - 관수 : 모든 것을 의인화하는 것이 객체지향의 핵심이 아닐지?

## TradeOff
 
- 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
 - 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 설게는 트레이드 오프의 산물임

# 객제치향 설계

- 설계: 코드를 배치하는 것 
 - 설계는 코드 작성의 일부이며, 코드를 작성하지 않고서는 검증할 수 없다. 

## 좋은 설계
 
- 오늘 완성해야하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 
- 변경을 수용할 수 있는 설계가 중요한 이유 : 코드를 수정하면 버그가 추가될 가능성이 높기때문
 - 버그의 가장 큰 문제점은 코드를 수정하려는 의지를 꺾는 것 
 - 변경 가능한 코드란 이해하기 쉬운 코드
 - 세훈: 변경가능한 코드와 유연한 코드는 다를 수 있다. (특정 상황을 염두해둔 케이스와 완전히 오픈한 케이스가 다를 수 있기 때문이다.)

                                                        
