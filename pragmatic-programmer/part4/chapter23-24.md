# Chapter 23. 단정적 프로그래밍

- 코딩할 때 아래와 같은 자기기만을 훈련하지 말 것.
	- 이 코드를 지금부터 30년 동안이나 사용하지는 않을 테니까, 연도에 두 자리 수를 사용해도 괜찮아.
	- 이 에플리케이션을 외국에서 사용하는 일은 절대 없을텐데 뭐하러 국제화하지?
	- Count는 음수가 될 수 없어.
	- 이 printf는 실패할 수 없어

- “하지만 물론 그건 절대 일어나지 않을 거야.” 라는 생각이 든다면, 단정문(assert)을 사용하라.	

> 실용주의 프로그래머 Tip.33  
> 단정문을 사용해서 불가능한 상황을 예방하라.

null이 와선 안된다면, 단정문을 사용하라.
```
void writeString(char *string) {
	assert(string != NULL);
	...
}
```
정렬이 잘 됬다고 과신하지 말고, 단정문을 사용하라.
```
for (int i=0; i<num_entries-1; i++) {
	assert(sorted[i] <= sorted[i+1]);
}
```

### 주의점
- 디버깅 행위가 디버깅되는 시스템의 행동을 바꿔버리는 문제를 조심하라.
```
while (iter.hasMoreElements()) {
	TEST.ASSERT(iter.nextElement() != null);
	Object obj = iter.nextElement();
	// ...
}
```
- 반드시 실행되어야 하는 코드는 단정문 안에 넣지 마라.
- 진짜 에러처리 대신으로 단정문을 사용하지 마라.
```
printf("Enter 'Y' or 'N': ");
ch = getChar();
assert((ch == 'Y' | ch == 'N'))
```
- 단정문은 예외를 생성할수도, 출구로 longjump할수도, 에러 핸들러를 호출할수도 있다.

### 단정 기능을 켜두라
- 프로그램을 출시할 때 단정기능을 꺼버리는 것은, 공중 곡예를 하면서 연습으로 한 번 건너봤다고 그물 없이 건너는 것과 비슷하다.
    - 테스트는 모든 버그를 발견할 수 없고,
    - 실제 프로그램이 동작하는 동안 어떤 변수도 생길 수 있다.
- 퍼포먼스에 문제가 있다면, 정말 문제되는 단정문만 끄자.
- 또는, 특정 단정문을 '옵션'으로 두는 방법도 있다.

### 연습문제
19. 간단한 현실 점검. 다음 '불가능한' 것들 중 무엇이 실제로 일어날 수 있는가?
1. 한달이 28일 보다 적은 것.
2. stat(".",&sb) == -1 9즉, 현재 디렉터리에 접근할 수 없다.)
3. C++에서, a = 2; b = 3; if(a+b != 5) exit(1);
4. 내각의 합이 180도가 아닌 삼각형
5. 60초가 아닌 1분
6. 자바에서, (a + 1) <= a

# Chapter 24. 언제 예외를 사용할까
### 무엇이 예외적인가
예외를 비예외적인 상황에 사용해선 안된다.
- 코드가 파일을 열어 읽으려고 할 때, 그 파일이 존재하지 않는다면 예외가 발생해야 할까? 정답은 '경우에 따라 다르다'
    - 파일이 반드시 있어야 하는 경우 -> 예외 발생
    - 그렇지 않다면 -> 에러 반환
```
// 유닉스 시스템에서 /etc/passwd는 반드시 존재해야 한다.
public void open_passwd() throws FileNotFoundException {
    // 다음은 FileNotFoundException을 던질 수도 있다.
    ipstream = new FileInputStream("/etc/passwd");
    //...
}
```

```
// 사용자가 지정한 파일을 여는 메서드. 예외가 당연시 되지 않는다.
public boolean open_user_file(String name) throws FileNotFoundException {
    File f = new File(name);
    if (!f.exists()) {
        return false;
    }
    ipstream = new FileInputStream(f);
    return true;
}
```
위 코드는 예외가 생길 경우 위로 넘긴다. 하지만 그 예외는 오로지 정말 예외적인 상황 하에서만 생성될 것이다. 단순히 존재하지 않는 파일을 열려고 하는 것으로는 일반적인 에러 반환만 생긴다.

> 실용주의 프로그래머 Tip.34  
> 예외는 예외적인 문제에 사용하라.

### 왜 이렇게 처리해야 할까?
- 예외를 정상적인 처리 과정의 일부로 사용하는 경우...
    - 고전적인 스파게티 코드의 가독성 문제와 관리성 문제를 전부 떠안게 된다.
    - 캡슐화를 꺠트린다 (예외 처리를 통해 루틴과 그 호출자들 사이의 결합도가 높아져 버린다.)
    
### 에러 처리기는 또 다른 대안이다
- 에러 처리기 : 에러가 감지되었을 때 호출되는 루틴
- 에러 처리를 예외 대신, 혹은 에러와 함께 사용하길 원하는 경우가 있을 것.
- 예시
```
- 자바의 RMI 기능을 사용하는 클라이언트 서버 애플리케이션 구현 
- 원격 루틴 호출 시 RemoteException을 처리해야 한다.
- 하지만 로컬과 리모트 루틴 모두에서 작동하는 코드를 작성하기 어렵다
- 한 가지 우회로는 원격이 아닌 클래스로 원격 객체를 wrap하는 것.
- 클래스에서 에러 처리기 인터페이스를 구현하여, 예외 감지 시 호출 루틴을 클라이언트 코드가 등록하도록 한다.

```


### 연습문제
21. 새로운 컨테이너 클래스를 설계하는 동안, 다음과 같은 에러 조건이 가능하다는 것을 발견한다.
1. add 루틴에서 새로운 원소를 위한 메모리가 부족하다.
2. fetch 루틴에서 요청된 엔트리를 찾을 수 없다.
3. add 루틴에 null 포인터가 전달되었다.
이것들은 각각 어떻게 처리되어야 하는가? 에러가 생성되어야 하나, 혹은 예외가 발생되어야 하나, 아니면 그 조건을 무시하는게 좋은가?