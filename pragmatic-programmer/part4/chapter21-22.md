## 계약에 의한 설계
> 상식과 정직만큼 사람을 놀라게 하는 건 없다.
>
>랄프 왈도 에머슨, 에세이

* 정직한 거래를 보장하는 최선의 해법 중 하나는 계약
* 계약은 상대편은 물론 자신의 권리와 책임을 정의
* 한쪽이 계약을 어겼을 경우의 손해에 대해서도 계약 사항에 포함
* 소프트웨어에서도 계약이 존재함

### DBC
* 계약에 의한 설계
* 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈들의 권리와 책임을 문서화
* 정확한 프로그램이란, 스스로 자신이 하는 일이라고 주장하는 것보다 많거나 적지도 않게 딱 그 만큼만 하는 프로그램
* 이것을 문서화하고, 검증하는 것이 계약에 의한 설계(DesignBy Contact; DBC)임
* 함수/메서드는 무언가를 하고, 그 루틴이 시작되기 전에 해당 루틴이 세상에 상태에 대한 어떤 기대와 루틴이 시작된 후에 루틴이 세상에 상태에 대한 기대가 존재할 것
  * 선행조건(Precondition): 루틴이 호출되기 위해 참이어야하 하는 것, 제대로된 데이터를 전달하는 것은 호출하는 쪽의 책임
  * 후행조건(Postcondition): 루틴이 자기가 할 것이라고 보장하는 것. 즉 루틴이 완료되었을 때 세상의 상태.
  * 클래스 불변식(Class Invariant): 호출자 입장에서 볼 때는 이 조건이 언제나 참이라고 클래스가 보장한다. 루틴의 내부 처리 중에는 불변식이 참이 아닐 수 도 있지만, 루틴이 종료하고 호출자로 제어권이 반환되는 때에는 불변식이 참이 되어야 한다.

#### 예시
* 유일한 값으로 구성 / 순서가 있는 / 리스트에 값을 집어넣는 루틴을 생각
```java
/**
 * @invariant forall Node n in elements() 
 *  n.prev() != null
 *  implies
 *    n.value().compareTo(n.prev().value()) > 0
 */
public class dbc_list {
  /**
   * @pre contains(aNode) == false
   * @post contains(aNode) == true
   */
  public void insertNode(final Node node) { }
}
```
* 리스트의 노드는 항상 증가하는 순서대로 정렬되어 있어야함
* 이미 존재하는 노드는 삽입 불가능
* 삽입 후에는 노드가 리스트 내에 존재해야함
* iContract을 통해서 이러한 계약 조건을 코드에 넣을 수 있다
  * iContract는 일반 자바 컨스럭트 외에도 술어 논리 연산자 - forall, exists, implies - 를 제공함
* 루틴과 그 루틴의 잠재적 호출자 간의 계약은 다음과 같음
  * 만약 호출자가 루틴의 모든 선행조건을 충족한다면, 해당 루틴은 종료시 모든 후행조건과 불변식이 참이 될 것을 보증해야 한다.
  * 만약 계약 당사자 중 어느 한쪽이든 이 계약 내용을 지키지 못하면, 예외가 발생하거나, 프로그램이 종료하거나 하는 배상이 이루어짐
>실용주의 그로그래머 Tip 31
>
> 계약에 따른 설계를 하라.

#### 게으른 코드
* 시작하기 전에 자신이 수용할 것에 대해서는 엄격하게 하고, 내어줄 것에 대해서는 최소한도를 약속
* 무엇이든 수용 / 모든걸 주는 코드는 작성하기가 어려움

#### 리스코트 대체 원칙 (Liskov Substitution Principle)
> 서브 클래스는 사용자가 차이점을 모르고서도 기반 클래스 인터페이스를 통해 사용할 수 있어야 한다.

* 새 서브타입이 정말 베이스타입의 '한 종류'여야 한다.
  * 동일한 메소드들을 지원
  * 그 메소드들은 동일한 의미를 가져야함
  * 서브클래스는 원한다면 좀 더 넓은 범위의 입력을 받아들이거나, 혹은 더 강한 보증을 할 수 있음
  * 자신의 부모 이상으로 받아들이고(선행조건이 약하고), 최소한 자신의 부모만큼은 보증해야 한다(후행조건이 같거나 강해야함)
* 예를 들어,
  * java.awt.Component에 Component를 상속하는 많은 다른 하위 클래스들이 존재한다.
  * 이들은 Component에 의해 정의된 기본 기능을 모두 지원해야한다.
  * 새로 생성한 하위 Component가, 그림을 그리지 않지만 paint라는 이름을 가진 메소드를 만들거나, 폰트를 설정하지 않는 setFont 메소드가 나올 수 있다.
  * 하지만 하위 클래스가 이러한 계약 조건을 위반하였는지를 부모 클래스가 알 수 없다.
  * 메서드 시그니처를 준수하였는가를 컴파일러를 통해 확인할 수 있는 것이 전부이다.
* 하지만 계약을 만들면, 미래의 서브클래스이건 우리의 메서드의 의미를 변경할 수 없게 된다.

#### DBC 구현
* 최고의 장점은, 요구사항과 보증의 문제를 전면으로 내세운다는 것
* 입력 도메인 범위가 무엇인지, 경계 조건이 무엇인지, 루틴이 뭘 전달한다고 약속하는지와 같은 것들을 설계시기에 나열하는 것만으로 엄청난 효과
* DBC는 설계 기법이므로, 자동 검사가 없이도 계약을 코드에 넣어서 강제할 수 있다.
* 주석으로 쓰인 계약은 뭔가 문제가 발생했을 때 우선 살펴 봐야할 곳이 될 것

#### 단정문
* 단정문을 통해 계약을 검사하도록 한다면 더 편하겠지만, 부분적으로 할 수 밖에 없다.
* 상속 계층을 따라 단정문이 밑으로 전파되도록 하는 지원이 존재하지 않는다.
* 계약이 있는 기반 클래스 메서드를 재정의하면 해당 계약을 구현하는 단정문은 올바르게 호출되지 않게 된다.
* 계약이 자동으로 집행되지 않는다.
* 이전(old) 값이라는 개념이 내장되어 있지 않다. 

#### 언어 지원
* Eiffel과 Sather는 선/후행 조건을 컴파일러와 런타임 시스템에서 자동으로 검사함
* 모든 코드기반이 각자 계약을 엄수해야함
* 일반적인 언어(C/C++/Java)는 원 소스코드에 특별한 주석무능로 포함된 계약을 처리하는 전처리기가 있다.
* 전처리기는 이 주석문을 단정문을 검사하는 코드로 확장해준다.
  * C/C++의 경우 Nana가 런타임에 디버거를 사용해서 단정문을 감시하는 새로운 방법을 제공함
  * Java의 경우 iContact가, 주석을 받아서 단정문 로직이 포함된 새로운 소스 파일을 생성함

#### DBC와 일찍 멈추기
* 문제를 찾고 원인을 밝히기 위해서는, 사고가 났을 때 일찍 멈추는 것이 유리하다.
* 그래야 어느 검사를 충족시키지 못하고, 프로그램이 종료되었는지를 stacktrace를 통해 쉽게 추적이 가능함

#### 불변식의 다른 용도
##### 루프 불변식
* 루프 불변식은 루프의 최종 목적에 대한 진술문이지만, 일반화 되어 있기 때문에 루프가 시작하기 전과 루프 진행 중 매 반복시 적용된다.
* 최대값을 찾는 루틴
```java
int m = arr[0];
int i = 1;
  while (i < arr.length) {
    m = Math.max(m, arr[i]);
    i = i + 1;
}
``` 
* 불변식은 루프가 실행되기 전에 참이이어야 하고, 루프가 실행되는 동안에도 역시 참이 되도록 루프의 몸체가 보증해 주어야 한다.
* 이렇게 해서 루프가 종료할 때에도 역시 불변식이 참이라는 걸 알 수 있고, 따라서 우리의 결과는 유효하다.

##### 의미론적 불변식
* 일종의 철학적 계약인 불변의 요구사항을 표현할 수 있다.
* 동일한 트렌젝이션이 계좌에 절대 두번 적용되지 않는다.
  * 이러한 의미론적 불변식은 복잡한 에러 복구 시나리오를 해결하는데에 큰 도움이 되는 것이 입증되었다.
* 일시적인 정책 (더 동적인 비즈니스 법칙)에 영향을 받으면 안된다.

## 죽은 프로그래미은 거짓말을 하지 않는다
* 프로그램에서 뭔가 잘못되기 시작하면 그걸 먼저 잡아내는 것은 라이브러리 루틴인 경우가 종종 있음
* '그런 일은 절대 일어날 리 없어' 라는 사고에 빠지기 쉽지만, 그리고 문제의 코드는 정상 조건 하에서는 실패하지 않았을 것이지만, 우리는 지금 방어적으로 코딩하고 있다.
* 모든 에러는 정보를 준다. 여러분은 에러가 발생할 리 없다고 스스로를 설득하고선 그걸 무시하기로 할 수 있다.
> 실용주의 프로그래머 Tip 32
>
>일찍 작동을 멈추게 하라.

##### 망치지 말고 멈추라
* 가능한 한 빨리 문제를 발견하게 되면, 좀 더 일찍 시스템을 멈출 수 있다는 이득이 있다.
* 프로그램을 멈추는 것이 최선일 때가 많다.
* 자바 라이브러리에서는 런터임 중에 이러한 애러가 발견되면 RE을 던진다. 이 예외가 Catch되지 않으면 프로그램의 최상위 수준까지 RE가 노출되고, 결국 스텍 트레이스를 출력하며 프로그램은 멈추게 된다.
* 물론 바로 프로그램을 종료시키는 것이 좋지 않을 수 있다.
  * 해제되지 않은 자원이 있을 수 있고,
  * 로그 메시지를 기록해야할 수 있고,
  * 열려있는 트랜잭션을 청소하고나
  * 다른 프로세스들과 상호작용해야할 수 있다.
* 하지만 되도록 빨리 종료하는 것이 좋다.
